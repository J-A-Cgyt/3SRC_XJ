//此文档用于存放已经使用过的在主函数中测试各功能函数的配合代码

/*
	Temp_Buffer = Thershold_区域(SRC_2nd);
	Temp_Array.push_back(Temp_Buffer);
	//Temp_Buffer.release();
	imshow(window_name, Temp_Array[0]);
	waitKey(0);
	局部阈值测试代码，已验证，20191120
*/


/* 注释于2020/1/16
	xfeatures2d::HarrisLaplaceFeatureDetector HARRIS; //xfratures2d相关功能的测试，用于角点检测->图像拼接等
	std::vector<cv::KeyPoint> K_Points; //关键点？角点？
	Mat map = SRC_2nd.clone();
	HARRIS.compute(SRC_2nd, K_Points, map); //不敢跑 2019-12-3 还是要cmake编译？
	imshow(window_name, Temp_Array[0]);
	waitKey(0);
*/


//Temp_Buffer = JiaoDian_SURF_CGYT(Temp_Array[0], Temp_Array[1]); //SURF方法+暴力匹配实现 20200215
//LSD_cgyt(Temp_Array[0]);                                        //线段检测测试代码 20200220
//DST_2nd = FenShuiLing_CGYT(Temp_Array[0]);                      //分水岭分割代码实现 20200222
//Temp_Buffer = FAST_dect_Cgyt(Temp_Array[0], Temp_Array[1]);     //FAST特征检测+Brief描述符+K-NN匹配实现 20200224 
//cout << Solve_Cgyt(0.73) << endl;                               //迭代求解测试 20200303


//以下是亚像素检测实现的前置处理

	Temp_Buffer = Gaosi_双边(Temp_Array[0]); //高斯滤波+锐化
	//imshow(window_name, Temp_Buffer);
	//waitKey(0);
	Temp_Array.push_back(Temp_Buffer);

	Canny(Temp_Array[1], Temp_Buffer, 80, 240); //canny边缘检测
	//imshow(window_name, Temp_Buffer);
	//waitKey(0);
	Temp_Array.push_back(Temp_Buffer);

	vector<vector<Point>> Contours_Dected, Contours_Seletced;
	vector<Point> Contours_for_SubPixCont;
	vector<Point2d> Contours_subPix_result;
	Moments 矩;
	findContours(Temp_Array[2], Contours_Dected, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point());  //圆形特征初步定位	
	for (int i = 0; i < Contours_Dected.size(); i++)
	{
		size_t k = Contours_Dected[i].size();
		if (k < 1000 && k > 700)
		{
			矩 = moments(Contours_Dected[i]);
			if (abs(矩.nu11) < 0.001)
			{
				//判定归一化的高阶中心距作为判断标准，可能四个三阶归一化中心矩均为极小数10e-4级别可认为在x、y方向均不存在偏向性，可认为该形状本身旋转不变		
				Contours_Seletced.push_back(Contours_Dected[i]);
			}
		}
	}
	Contours_for_SubPixCont = Contours_Seletced[0];
	cvtColor(Temp_Array[0], Temp_Buffer, COLOR_GRAY2BGR);
	drawContours(Temp_Buffer, Contours_Seletced, -1, Scalar(0, 0, 255));
	imshow(window_name, Temp_Buffer);
	waitKey(0);
	Temp_Array.push_back(Temp_Buffer); //指针问题未明确，注意传输地址导致vector容器中内容一致的可能


	/*
	Temp_Array检查
	for (int k = 0; k < Temp_Array.size(); k++)
	{
		imshow(window_name, Temp_Array[k]);
		cout << k << endl;
		waitKey(0);
	}
	*/

	//Temp_Array[1]是canny检测结果
	//SubPixel_Contours_Cgyt(Temp_Array[1],Contours_for_SubPixCont);
	
	//亚像素边缘检测代码
	//Contours_subPix_result = SubPixel_Contours_Cgyt(Temp_Array[0], Contours_for_SubPixCont);

}

//以下启动测试 空间矩亚像素检测需要亚像素检测的前置代码，从code_used中转移至此 20200415 注意重复
	//以下是亚像素检测实现的前置处理
	Temp_Buffer = Gaosi_双边(Temp_Array[0]); //高斯滤波+锐化
	//imshow(window_name, Temp_Buffer);
	//waitKey(0);
	Temp_Array.push_back(Temp_Buffer);

	Canny(Temp_Array[1], Temp_Buffer, 80, 240); //canny边缘检测
	//imshow(window_name, Temp_Buffer);
	//waitKey(0);
	Temp_Array.push_back(Temp_Buffer);

	vector<vector<Point>> Contours_Dected, Contours_Seletced;
	vector<Point> Contours_for_SubPixCont;
	vector<Point2d> Contours_subPix_result;
	Moments 矩;
	findContours(Temp_Array[2], Contours_Dected, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point());  //圆形特征初步定位	
	for (int i = 0; i < Contours_Dected.size(); i++)
	{
		size_t k = Contours_Dected[i].size();
		if (k < 1000 && k > 700)
		{
			矩 = moments(Contours_Dected[i]);
			if (abs(矩.nu11) < 0.001)
			{
				//判定归一化的高阶中心距作为判断标准，可能四个三阶归一化中心矩均为极小数10e-4级别可认为在x、y方向均不存在偏向性，可认为该形状关于X，Y轴均对称		
				Contours_Seletced.push_back(Contours_Dected[i]);
			}
		}
	}
	Contours_for_SubPixCont = Contours_Seletced[0];
	cvtColor(Temp_Array[0], Temp_Buffer, COLOR_GRAY2BGR);
	drawContours(Temp_Buffer, Contours_Seletced, -1, Scalar(0, 0, 255));
	imshow(window_name, Temp_Buffer);
	waitKey(0);
	Temp_Array.push_back(Temp_Buffer); //指针问题未明确，注意传输地址导致vector容器中内容一致的可能

	//亚像素边缘检测代码
	Contours_subPix_result = SubPixel_Contours_Cgyt(Temp_Array[0], Contours_for_SubPixCont, 2);

保边滤波对比 20200424转移
	Temp_Buffer = Gaosi_双边(Temp_Array[0]);
	imshow(window_name, Temp_Buffer);
	waitKey(0);
	
	Temp_Buffer = NLM_CGYT(Temp_Array[0]); //也是属于实时性极差，如果没有并行计算加速，几乎不可能
	imshow(window_name, Temp_Buffer);
	waitKey(0);


GPU初次测试，图像加减的配合代码  20200706转移
	SRC_2nd = imread(LoadPath_Msi_2, IMREAD_COLOR);
	Temp_Buffer = imread(LoadPath_Msi_3, IMREAD_COLOR);
	Temp_Array.push_back(SRC_2nd);
	imshow(window_name, Temp_Buffer);
	waitKey(0);
	Temp_Array.push_back(Temp_Buffer);
	GPU_func_study(Temp_Array[0], Temp_Array[1]);

模糊变换计时 20201008转移
	//Start = clock();
	//单线程版本
	//DST_2nd = MoHu_HuiDuBianHuan(SRC_2nd);
	//End = clock();

	//多线程版本
	//DST_2nd = MoHu_HuiDuBianHuan(SRC_2nd,1);
	//End = clock();

	//double endtime = (double)(End - Start) / CLOCKS_PER_SEC;
	//printf("Total time: %f ms \n", endtime * 1000);	//ms为单位

陈年旧码 包括眼动检测、扩散滤波等 20201025转移
	/*	
	Point3f center;
	center = IrisDect(Temp_Array[0],COUNTOUR);
	cvtColor(SRC_2nd, Temp_Buffer, COLOR_GRAY2BGR);
	circle(Temp_Buffer, Point(center.x, center.y), center.z, Scalar(0, 0, 255), 3);
	imshow(window_name, Temp_Buffer);
	waitKey(0);  //眼动检测的主程序代码，注释于20200705


	Temp_Buffer = Thershold_区域(SRC_2nd);
	Temp_Array.push_back(Temp_Buffer);
	//Temp_Buffer.release();
	imshow(window_name, Temp_Array[0]);
	waitKey(0);

	//第二部分的读取代码
	SRC_2nd = imread(Load_Path_2nd_2, IMREAD_GRAYSCALE);
	if (!SRC_2nd.data)
		{
			cout << "读取失败" << endl;
			return -1;
		}
	imshow(window_name, SRC_2nd);
	waitKey(0);
	Temp_Array.push_back(SRC_2nd);
	//读取代码结束

	Temp_Buffer = JiaoDian_SURF_CGYT(Temp_Array[0], Temp_Array[1]); //SURF方法+暴力匹配实现 20200215

	//vector<Point2f> subPix_Point;
	//subPix_Point = subPix_pt(Temp_Array[0]);

	//TrackBar_cgyt_canny(0, 0); //TrackBar重新熟悉

	//包含类的源文件该如何创建并添加至现有项目中？ 存在问题 20200318
	//Temp_Array.push_back(Conv_Cgyt(Temp_Array[0],SOBEL_CGYT)); 类的相关问题已在第三个项目中解决，至20200321未出现问题，一个源文件实现主函数，一个源文件实现类成员方法。而类定义写在另一个头文件中

	//FT_CGYT(Temp_Array[0]);  //傅里叶变换 20200323通过

	//int res_state = Calib_Cgyt(Temp_Array[0]); 注释与20200410
	//cout << res_state;

	Temp_Buffer = Anisotropic_Cgyt(Temp_Array[0], 20, 0.75, 10);
	imshow(window_name, Temp_Buffer);	
	imwrite("G:\\Pictures\\Test For Programming\\003.2.jpg", Temp_Buffer);
	cout << "end" << endl;
	waitKey(0);
	
	Temp_Buffer = AnisotropicMT_Cgyt(Temp_Array[0], 20, 0.75, 10);

	Temp_Buffer = WaveLetHarrD_CGYT(Temp_Array[0], 1);
	imshow(window_name, Temp_Buffer);
	waitKey(0);

	Temp_Array[0] = WaveLetHarrR_CGYT(Temp_Buffer, 1);
	imshow(window_name, Temp_Array[0]);
	waitKey(0);
	*/

C++学习代码 202001025转移
	Temp_Array.push_back(Mat());
	auto iterMB = Temp_Array.begin(); //整一个开始的迭代器
	*iterMB = Temp_Buffer.clone();    //现在开始试一下迭代器吧，逐渐把容器访问的习惯改过来
	Temp_Array.push_back(Temp_Buffer);
	Temp_Buffer = imread(LoadPath_Msi_C, IMREAD_GRAYSCALE);

20210309转移 眼睛的亚像素
		//以下是亚像素检测实现的前置处理
	Temp_Array.push_back(SRC_2nd);

	auto iter_A = Temp_Array.begin();
	equalizeHist(SRC_2nd, *iter_A);
	imshow(window_name, *iter_A);
	waitKey(0);
	Mat kernel = getStructuringElement(MORPH_CROSS, Size(7, 7));  //形态学卷积核
	morphologyEx(*iter_A, *iter_A, MORPH_OPEN, kernel);  //形态学操作
	imshow("Demo_Result", *iter_A);
	waitKey(0);
	threshold(*iter_A, *iter_A, 20, 255, THRESH_BINARY);  //看来得用OSTU了
	//GaussianBlur(*iter_A, *iter_A, Size(15, 15), 0);
	//threshold(*iter_A, *iter_A, 10, 255, THRESH_BINARY_INV);
	imshow("Demo_Result", *iter_A);
	waitKey(0);

	vector<vector<Point>> Contours_Dected, Contours_Seletced;
	vector<Point> Contours_for_SubPixCont;
	vector<Point2d> Contours_subPix_result;
	Moments 矩;
	findContours(Temp_Array[0], Contours_Dected, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point());  //圆形特征初步定位	
	for (int i = 0; i < Contours_Dected.size(); i++)
	{
		size_t k = Contours_Dected[i].size();
		if (k < 1000 && k > 700)
		{
			矩 = moments(Contours_Dected[i]);
			if (abs(矩.nu11) < 0.001)
			{
				//判定归一化的高阶中心距作为判断标准，可能四个三阶归一化中心矩均为极小数10e-4级别可认为在x、y方向均不存在偏向性，可认为该形状关于X，Y轴均对称		
				Contours_Seletced.push_back(Contours_Dected[i]);
			}
		}
	}
	if (Contours_for_SubPixCont.size() == 0) { throw out_of_range("没有符合条件的素材边缘!"); return -1; }
	Contours_for_SubPixCont = Contours_Seletced[0];
	cvtColor(Temp_Array[0], Temp_Buffer, COLOR_GRAY2BGR);
	drawContours(Temp_Buffer, Contours_Seletced, -1, Scalar(0, 0, 255));
	imshow(window_name, Temp_Buffer);
	waitKey(0);
	Temp_Array.push_back(Temp_Buffer); //指针问题未明确，注意传输地址导致vector容器中内容一致的可能


20210430转移
	//亚像素边缘检测代码
	Contours_subPix_result = SubPixel_Contours_Cgyt(Temp_Array[0], Contours_for_SubPixCont, 2.0);

		//要不到时单独开一个线程用来传输 join还是要的 否则引用的内存区被清理了估计得报错 似乎不能应用俩参数 写几个就得几个 20210317暂时注释
	//std::thread tSend = thread(ContoursSubpixSend,subpixPoints); 
	//tSend.join();

	//HistogramCGYT(SRC_2nd);
	//FT_CGYT(SRC_2nd, Temp_Buffer);
	//Filter_Freq(Temp_Buffer,4);
	//Temp_Buffer = HarmonicMeanFilter(SRC_2nd, 2,1,1);

//一下内容 20201025玩一下 C++习惯和新知识的练习试验

	
	//imshow(window_name, DST_2nd);
	//waitKey(0);

	//Temp_Buffer = CannyG_Cgyt(SRC_2nd);
	//HoughLineG_Cgyt(Temp_Buffer);
	//threshold(SRC_2nd, Temp_Buffer, 200, 255, THRESH_BINARY);
	//Components_Connected_cgyt(Temp_Buffer);
	//FaceG_cgyt(SRC_2nd);  //此函数GPU版本报错 不可用不知道啥没实现 CPU可行
	//IrisDectH_GPU(SRC_2nd);
	//ORBG_cgyt(SRC_2nd);
	//SURFG_cgyt(SRC_2nd, Temp_Buffer); //surf的GPU版本配合代码，20200723注释